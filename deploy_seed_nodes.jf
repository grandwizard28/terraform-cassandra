#!groovy

pipeline {
    environment {
        AWS_REGION = "us-east-1"
        S3_BUCKET_NAME = "wizards-cassandra-config"
        S3_BUCKET_KEY = "${params.environment}/cassandra/${name}"
    }
    agent any
    stages{
        stage("Setup Parameters"){
            steps {
                script {
                    properties([
                        parameters([
                            string(
                                name: 'name',
                                description: '[Mandatory] Name of cluster',
                                defaultValue: 'cassandra-cluster',
                                trim: true
                            ),
                            choice(
                                name: 'environment',
                                description: '[Mandatory] Environment to deploy into',
                                choices: ['development', 'staging', 'production'], 
                                defaultValue: 'production',
                                trim: true
                            ),
                            string(
                                name: 'ami',
                                description: '[Mandatory] Ubuntu AMI of underlying EC2 instance',
                                defaultValue: 'ami-07ebfd5b3428b6f4d',
                                trim: true
                            ),
                            string(
                                name: 'vpc_id',
                                description: '[Mandatory] ID of VPC to deploy into',
                                defaultValue: 'ami-07ebfd5b3428b6f4d',
                                trim: true
                            ),
                            string(
                                name: 'subnet_ids',
                                description: '[Mandatory] Comma Separated List of Subnet IDs of VPC to deploy into',
                                defaultValue: 'subnet-cff6f78254323,subnet-cff6f782hu424,subnet-cff6f782oi988',
                                trim: true
                            ),
                            string(
                                name: 'instance_type',
                                description: '[Mandatory] Instance Type of underlying EC2',
                                defaultValue: 't2.small',
                                trim: true
                            ),
                            string(
                                name: 'num_instances',
                                description: '[Mandatory] Number of nodes in cluster',
                                defaultValue: 't2.small',
                                trim: true
                            ),
                        ])
                    ])
                }
            }
        }

        stage('Initialize Ingredients'){
            steps{
                script{
                    checkout scm
                }
            }
        }

        stage('Execute Terraform'){
            steps{
                script {
                        execute_terraform()  
                }
            }

        }

        stage('Create Config Files'){
            steps{
                script{
                    def seed_nodes_private_ips = get_seed_nodes_private_ips()
                    print "seed_nodes_private_ips inside creare config files: ${seed_nodes_private_ips}"
                    prepare_config_files(params.name, seed_nodes_private_ips)
                }
            }
        }

        stage('Upload Config Files to S3'){
            steps{
                script{
                    sh(script: "aws s3 cp config s3://${env.S3_BUCKET_NAME}/${env.S3_BUCKET_KEY}/ --recursive")
                }
            }
        }

        stage('Audit'){
            steps{
                script{
                    print "Audit"
                }
            }

        }
    }

}

def execute_terraform(){
    dir("terraform"){
    def returnStatus = sh(script: "/usr/local/bin/terraform init", returnStatus: true)
    if(returnStatus!=0){
        error("Unable to execute terraform init")
    }

    // returnStatus = sh(script: "/usr/local/bin/terraform plan -var 'CONFIG_BUCKET_NAME=${env.S3_BUCKET_NAME}' -var 'CONFIG_BUCKET_KEY=${env.S3_BUCKET_KEY}' -out=apply.tf", returnStatus: true)
    // if(returnStatus!=0){
    //     error("Unable to execute terraform plan")
    // }

    // returnStatus = sh(script: "/usr/local/bin/terraform apply -auto-approve apply.tf", returnStatus: true)
    // if(returnStatus!=0){
    //     error("Unable to execute terraform apply")
    // }

    // returnStatus = sh(script: "rm apply.tf", returnStatus: true)
    // if(returnStatus!=0){
    //     error("Unable to remove apply.tf")
    // }
    }
}

def get_seed_nodes_private_ips(){
    def seed_nodes_private_ips = sh(script: "/usr/local/bin/terraform output -json -state=teststate.tfstate cassandra_seed_nodes_private_ips", returnStdout: true)
    
    print "seed_nodes_private_ips : ${seed_nodes_private_ips}"
    return seed_nodes_private_ips
}

def prepare_config_files(name, seedNodePrivateIPs){
    def replaceNameReturnStatus = sh(script: "sed -i 's/@@NAME_OF_CLUSTER@@/${name}/g' config/cassandra.yaml", returnStatus: true)
    print "seedNodePrivateIPs inside prepare_config_files: ${seedNodePrivateIPs}"
    def joined = seedNodePrivateIPs.join(',')
    print "seedNodePrivateIPs inside prepare_config_files: ${joined}"
    def replaceSeedNodePrivateIPsReturnStatus = sh(script: "sed -i 's/@@LIST_OF_SEED_NODES@@/${joined}/g' config/cassandra.yaml", returnStatus: true)
}
